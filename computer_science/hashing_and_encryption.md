# 해싱과 암호화

> 2가지 암호화(cryptography) 기법

### 해싱 (Hashing)

- **해시 함수**를 통해 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑하는 방식

- 해싱의 특징

  - **결정론적** : 같은 입력값에 대하여 언제나 같은 해시값이 나온다.

  - **단방향** : 데이터를 통해 해시값을 얻을 수 있지만, 해시값을 통해 원본 데이터를 얻을 수는 없다. (즉, 암호화는 가능하지만 복호화는 불가능하다.)
    - 따라서 비밀번호를 저장하는 데 주로 사용된다.

- Q. 취약점은 없는가?

  - 무차별 데이터를 해시 함수에 대입하면서 원본 데이터를 찾아낼 수 있다. (해싱의 결정론적 특성)
  - **레인보우 테이블** : 해시 함수를 사용하여 만들어낼 수 있는 값들을 저장한 표

- Q. 취약점은 어떻게 보완할 수 있는가?

  - 해시 함수를 여러 번 적용하는 방법
  - **솔팅(salting)** : 원본 데이터에 임의의 문자열인 **솔트(salt)**를 덧붙이는 방법
    - 비밀번호를 예로 들면, 각 사용자마다 비밀번호에 다른 솔트 문자열을 붙인 뒤 해시 함수의 반환값을 저장한다.
  - 2가지 방법을 혼용하여, 해시 함수를 적용할 때마다 솔트를 덧붙일 수도 있다.

- ex. MD5, SHA-256, SHA-512 등

<br>

### 암호화 (Encryption)

- 평문 데이터를 암호화된 데이터로 변환시키는 방식

- 암호화의 특징
  - **양방향** : 암호화와 복호화가 모두 가능하다.
- **대칭키 암호화 방식**
  - 암호화와 복호화에 같은 키를 사용한다.
  - 단점 1 : 대칭키를 알면 암호를 복호화할 수 있기에, 보안상 문제가 있다.
  - 단점 2 : A가 B, C와 데이터를 주고받는 경우, B와 통신할 때와 C와 통신할 때 다른 대칭키를 사용해야 한다. 통신하는 상대가 많아질수록 많은 키가 필요할 것이다.
  - ex. DES, AES 등
- **비대칭키(공개키) 암호화 방식**
  - 두 개의 키를 사용하는데, 하나의 키로 암호화하면 다른 키로 복호화할 수 있다.

    - 공개키로 암호화하고, 개인키로 복호화할 수도 있고,
    - 개인키로 암호화하고, 공개키로 복호화할 수도 있다.
  - 개인키를 공유하지 않아도 되므로 대칭키 암호화 방식보다 안전하다.
  - ex. RSA 등

<br>

### HTTP vs HTTPS

> 응용 계층 프로토콜

- **HTTP**는 하이퍼텍스트를 교환하기 위한 프로토콜로, **80번 포트**를 사용한다.
  - HTTP의 경우 암호화를 하지 않기에, 데이터를 중간에서 가로채거나 변조할 수 있으며, 통신 상대를 확인하지 않기에 위장도 가능하다.
- **HTTPS**는 HTTP의 보안 문제를 해결하기 위해 등장한 프로토콜이다.
  - HTTP에 데이터 암호화가 추가된 프로토콜로, **443번 포트**를 사용한다.
- HTTPS는 데이터 암호화를 위해 **SSL/TSL 프로토콜**을 사용한다.
  - TLS은 SSL을 표준화한 방식이다.
  - SSL 프로토콜은 전송계층(TCP)과 응용계층(HTTP) 사이에 위치한다.
- HTTPS에서 클라이언트와 서버는 TCP Handshake 이후 추가적으로 SSL Handshake를 수행한다. SSL Handshake가 완료된 이후 암호화된 데이터를 주고받는다.
- SSL 연결을 통해 데이터를 암호화하더라도, header 부분은 여전히 노출된다.
  - **GET** 요청의 경우 서버에 전달할 데이터를 URL의 쿼리 스트링에 전달하며, 이는 HTTP 메시지의 header에 포함된다. 따라서 중요한 정보를 담아 보낼 때는 GET 요청으로 보내지 않는 것이 좋다.

<br>

### SSL Handshake

> 대칭키 방식을 사용하되, 대칭키를 암호화하는 방식은 공개키 방식을 사용한다

1. **Client Hello**

   - 클라이언트가 서버에 접속한다.

   - 클라이언트의 랜덤 데이터, 지원하는 암호화 방식의 목록을 전달한다.
  2. **Server Hello**

     - 서버가 클라이언트에 응답한다.

     - 선택한 클라이언트의 암호화 방식, 서버의 랜덤 데이터, SSL 인증서를 전달한다.
       - SSL 인증서에는 서비스의 정보 및 서버 측 공개키가 담겨 있으며, 인증기관의 개인키로 암호화되어 있다.
3. 클라이언트는 SSL 인증서가 CA(인증기관)에서 발급한 것인지 확인한다.

   - CA의 공개키로 인증서를 복호화한다. 성공한다면 인증서가 CA의 개인키로 암호화된 것임을 알 수 있다.

   - 이후 클라이언트의 랜덤 데이터와 서버의 랜덤 데이터를 조합하여 pre master secret(PMS)라는 값을 생성한다.

   - PMS 값을 SSL 인증서에 담긴 서버의 공개키로 암호화하여 서버로 보낸다.
4. 서버는 암호화된 PMS 값을 개인키로 복호화한다.
   - 클라이언트와 서버는 각각 PMS 키로 session key를 생성한다.
5. 클라이언트와 서버는 핸드쉐이크의 종료를 서로에게 알린다.
   - 이후 session key를 사용하여 대칭키 방식으로 암호화된 데이터를 주고받다가, 데이터 전송이 끝나면 session key를 폐기한다.

<br>

### 참고 자료

https://opentutorials.org/course/228/4894

https://www.geeksforgeeks.org/difference-between-hashing-and-encryption/

https://st-lab.tistory.com/100