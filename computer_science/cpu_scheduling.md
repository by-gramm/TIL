# CPU Scheduling



### Why : CPU 스케줄링은 왜 필요한가

**CPU burst**

- 사용자 프로그램이 직접 CPU를 가지고 빠른 명령을 수행하는 단계

**I/O burst**

- I/O 요청이 발생해 커널이 비교적 느린 입출력 작업을 진행하는 동안 기다리는 단계

**I/O bound process**

- I/O 요청이 빈번하여 CPU 버스트가 짧게 나타나는 프로세스

**CPU bound process**

- I/O 요청이 드물어 CPU 버스트가 길게 나타나는 프로세스

하나의 시스템 내에서 각기 다른 CPU 사용 패턴을 가진 프로세스가 함께 실행된다. 한 번에 CPU를 길게 사용하는 CPU 바운드 프로세스에 먼저 CPU를 할당하면, 해당 프로세스가 CPU를 사용할 때까지 다른 프로세스가 기다려야 한다. 

복사실에서 300페이지를 복사하는 사람 때문에 한 페이지만 복사해서 수업을 들으러 가야 하는 여러 사람이 기다려야 하는 상황을 생각해보자. 이때 복사기를 사용하는 것이 CPU를 할당받는 일이라면, 수업을 듣는 것은 입출력 작업을 수행하는 일이다. 결국 CPU를 누구에게 먼저 할당하느냐에 따라 입출력 작업의 효율성이 크게 달라질 수 있으므로, 어떤 프로세스에게 먼저 CPU를 할당할 지 결정하는 **CPU 스케줄링**이 필요하다.

<br>

### Who : CPU 스케줄링은 누가 담당하는가

**CPU Scheduler = 단기 스케줄러** 

- ready 큐에 있는 프로세스 중 어떤 프로세스에게 CPU를 할당할지 결정하는 코드
- cf) **장기 스케줄러 = Job Scheduler**
  - 시작 프로세스 중 어떤 것들을 ready 큐로 보낼지 결정하는 코드 

**Dispatcher**

- CPU의 제어권을 CPU 스케줄러가 선택한 프로세스에게 실제로 넘기는 코드
- 즉, Context Switch를 실행하는 코드
  - **Context Switch**
    - 하나의 프로세스에서 다른 프로세스로 CPU 제어권이 넘어가는 과정
  - 디스패처의 문맥 교환 과정
    - a. 현재 수행 중이던 프로세스의 문맥을 해당 프로세스의 PCB에 저장함.
    - b. 새로 CPU를 할당할 프로세스의 문맥을 PCB로부터 읽어옴.
    - c. 새로운 프로세스에게 CPU를 할당함.
- 디스패치 지연시간 : 디스패처가 a ~ c를 하는 데 걸리는 시간

<br>

### How : CPU 스케줄링의 성능은 어떻게 평가하는가

A. 시스템 관점의 성능 척도

- **CPU 이용률 (CPU Utilization)**
  - 전체 시간에서 CPU가 놀지 않고 일한 시간의 비율
- **처리량 (throughput)**
  - 주어진 시간 동안 ready 큐의 프로세스 중 완료한 작업의 개수

B. 사용자 관점의 성능 척도

- **소요 시간 (turnaround time)**
  - CPU를 요청한 시점부터 CPU를 다 쓰고 나갈 때까지 걸리는 시간
  - ready 큐에서 기다린 시간(waiting time) + 실제로 CPU를 사용한 시간(burst time)
- **대기 시간 (waiting time)**
  - ready 큐에서 CPU를 쓰기 위해 기다린 시간 (순수하게 기다린 시간)
- **응답 시간 (response time)**
  - ready 큐에 들어온 후 처음으로 CPU를 얻기까지 걸린 시간
  - 대화형 시스템에 적합한 성능 척도

<br>

### What : CPU 스케줄링 알고리즘에는 무엇이 있는가

**비선점형(Nonpreemptive)**

- CPU를 할당받은 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않음

**선점형(Preemptive)**

- 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있음



#### 1. FCFS (First-Come First-Served)

- ready 큐에 먼저 온 순서대로 CPU를 할당한다 (비선점형)

- 문제 : **Convoy Effect** 
  - 긴 프로세스가 먼저 와서 짧은 프로세스의 대기 시간이 길어지는 현상

#### 2. SJF (Shortest Job First)

- CPU 버스트 시간이 짧은 프로세스부터 CPU를 할당한다
  - 비선점형
  - 선점형 = **SRTF (Shortest Remaining Time First)**
    - 현재 수행중인 프로세스의 남은 CPU 버스트 시간보다 더 짧은 CPU 버스트 시간을 가지는 새로운 프로세스가 도착하면, 해당 프로세스에게 CPU를 할당함.
    - 평균 대기 시간을 최소화하는 최적 알고리즘
- 우선순위 스케줄링의 일종

#### 3. 우선순위 스케줄링 (Priority Scheduling)

- 우선순위가 가장 높은 프로세스에게 CPU를 할당한다

  - 비선점형, 선점형 모두 가능

- 문제 : **기아 상태(starvation)**

  - CPU 버스트 시간이 긴 프로세스는 CPU를 계속 할당받지 못함.

  - 해결 : **노화(Aging) 기법** (오래 기다린 프로세스의 우선순위를 높임)

#### 4. RR (Round Robin)

- 각 프로세스에게 동일한 할당 시간을 부여하고, 할당 시간이 지나면 해당 프로세스를 ready 큐의 제일 뒤에 다시 추가한다.
  - 선점형
- 할당 시간이 너무 길면 => FCFS와 같아짐.
- 할당 시간이 너무 짧으면 => Context Switching의 오버헤드가 지나치게 커짐.
- 응답 시간이 빨라지므로 대화형 시스템에 적합

#### 5. 멀티레벨 큐 (multi-level queue)

- 전위 큐 : RR (대화형 작업)

- 후위 큐 : FCFS (계산 위주의 작업)

- 큐가 여러 개이므로 큐 자체에 대한 스케줄링이 필요

  - 고정 우선순위 방식

    - 전위 큐에 우선순위를 부여함.
    - 문제 : 기아 상태

  - 타임 슬라이스 방식

    - 각 큐에 CPU 시간을 일정한 비율로 할당함. (기아 상태 해결)

      (ex. 전위 큐 80%, 후위 큐 20%)

#### 6. 멀티레벨 피드백 큐 (multi-level feedback queue)

- 프로세스가 하나의 큐에서 다른 큐로 이동할 수 있음
- 노화 기법을 구현할 수 있음 (시간이 지날수록 우선순위가 높은 큐로 이동시키기)