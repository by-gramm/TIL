# Memory Allocation

#### 내용 출처

- [KOCW <운영체제> 강의](http://www.kocw.net/home/cview.do?cid=3646706b4347ef09)
- [책 <운영체제와 정보기술의 원리>](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589)

<br>

### 논리적 주소와 물리적 주소

- **논리적 주소 (Logical Address)**
  - 프로세스마다 독립적으로 가지는 **가상의** 주소 공간
  - 각 프로세스마다 0번지부터 시작한다.
  - CPU가 보는 주소가 논리적 주소
- **물리적 주소 (Physical Address)**
  - 물리적 메모리에 **실제로** 올라가는 위치

- **주소 바인딩**
  - 논리적 주소를 물리적 주소로 연결해주는 작업

<br>

### 내부 단편화와 외부 단편화

**내부 단편화 (internal fragmentation)**

- 분할의 크기보다 작은 프로그램이 적재되는 경우 남는 메모리 공간

**외부 단편화 (external fragmentation)**

- 프로그램보다 크기가 작아서 프로그램을 올리지 못하는 메모리 공간

<br>

### 물리적 메모리의 할당

보통 물리적 메모리의 낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다.

사용자 프로세스 영역의 2가지 할당 방법

- **연속 할당**
  - 각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것
- **불연속 할당**
  - 하나의 프로세스가 메모리의 여러 영역에 분산되어 올라가도록 하는 것
  - Paging / Segmentation / Paged Segmentation

<br>

### 연속할당 기법

**고정 분할 방식**

- 물리적 메모리를 몇 개의 영구적인 분할로 미리 나누어 관리한다.
- 분할당 하나의 프로그램만을 적재할 수 있다.
- 내부 단편화 및 외부 단편화가 발생할 수 있다.

**가변 분할 방식**

- 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용한다.
  - 따라서 내부 단편화는 발생하지 않는다.
- 외부 단편화는 발생할 수 있다. 메모리에 존재하던 프로그램이 종료된 경우 빈 공간이 발생하는데, 이 공간이 새로 메모리에 올릴 프로그램보다 크기가 작을 수 있기 때문이다.
- Q. 그렇다면 가변 분할 방식에서 외부 단편화를 해결할 방법은 없는가?
  - **compaction** : 물리적 메모리에서 사용 중인 영역을 한 곳으로 몰고, 사용되지 않는 가용 공간을 다른 쪽으로 몰아서 하나의 큰 가용 공간을 만든다.
  - 컴팩션은 비용이 크기 때문에 실제로는 잘 사용하지 않는다.
- 동적 메모리 할당 문제
  - 크기가 n인 프로세스를 메모리 가용 공간 중 어디에 적재할 것인가의 문제
  - **First-fit (최초적합)**
    - 크기가 n 이상인 것 중 최초로 찾아지는 hole에 할당한다.
    - 전체 hole을 탐색할 필요가 없으므로 속도가 가장 빠르다. (시간효율적)
  - **Best-fit (최적적합)**
    - 크기가 n 이상인 가장 작은 hole을 찾아서 할당한다.
    - 메모리 단편화가 가장 적게 발생한다. (공간효율적)
  - **Worst-fit (최악적합)**
    - 가장 큰 hole에 프로그램을 할당한다.

<br>

### 불연속할당 기법

- 현대의 컴퓨터 시스템은 주로 불연속 할당 기법을 사용한다.
- 하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라간다.



#### 페이징 (Paging)

- 프로세스의 주소 공간(논리적 메모리)를 동일한 크기의 **페이지(page)** 단위로 나눈다.
- 물리적 메모리를 동일한 크기의 **프레임(frame)** 단위로 나눈다.
  - 페이지와 같은 크기로 나눈다.
-  **페이지 테이블(page table)**을 사용하여 논리적 주소를 물리적 주소로 변환한다.

- 프로세스의 p번째 페이지에 접근하는 방법 : 해당 프로세스의 페이지 테이블의 p번째 주소에서 페이지 프레임 번호 f를 찾은 뒤, 물리적 메모리에서 f번째 주소를 찾는다.
- **TLB**
  - 페이지 테이블의 캐시 역할
  - 빈번하게 참조될 페이지에 대한 주소 변환 정보를 담는다. 이를 통해 캐시 적중률을 높이고자 한다.
  - **캐시 적중률** : `적중 횟수 / 총 접근 횟수`
  - Q. 빈번하게 참조될 페이지는 어떻게 알 수 있는가? 즉, 캐시 적중률을 어떻게 높이는가?
    - **시간 지역성** : 최근에 참조된 페이지는 다시 참조될 가능성이 높다.
    - **공간 지역성** : 참조된 페이지와 인접한 페이지가 다시 참조될 가능성이 높다.
  - 주소 변환 정보는 프로세스별로 다르므로, 문맥교환시 TLB를 초기화해야 한다.



#### 세그멘테이션 (Segmentaion)

- 프로그램을 구성하는 주소 공간을 기능 단위 혹은 의미 단위인 **segment**로 나눈다.
  - 의미 단위이므로 크기가 균일하지 않다.
- **세그먼트 테이블(segment table)**을 사용하여 논리적 주소를 물리적 주소로 변환한다.

- 세그먼트 테이블의 각 항목은 기준점과 한계점을 가진다.
  - **기준점(base)** : 물리적 메모리에서 세그먼트의 시작 주소
  - **한계점(limit)** : 세그먼트의 길이



#### 페이지드 세그멘테이션(Paged Segmentation)

- **Paging vs Segmentation**

  - 단편화 : 페이징에서는 물리적 메모리의 어떤 프레임이든 프로세스를 적재할 수 있으므로 외부 단편화가 발생하지 않는다. 반면 세그멘테이션에서는 세그먼트의 길이가 균일하지 않으므로, 외부 단편화가 발생한다.

  - 공유 및 보안 : 세그먼트는 의미 단위이기 때문에 공유와 보안에 있어 페이징 기법보다 훨씬 효과적이다. 주소 공간 일부를 공유하거나 특정 주소 공간에 접근 권한 제어를 하는 경우, 의미 단위로 이루어지기 때문이다.

- 둘의 장점을 결합한 방식이 바로 페이지드 세그멘테이션
- 프로그램을 의미 단위인 세그먼트로 나눈다. 단, 세그먼트의 길이는 반드시 페이지 크기의 배수가 되도록 한다. 이를 통해 외부 단편화 문제 및 공유/보안의 문제를 동시에 해결한다.