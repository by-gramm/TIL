# 쿠키와 세션



### 쿠키와 세션을 사용하는 이유

- HTTP의 2가지 특성
  - **Connectionless** : 서버는 클라이언트에 응답을 한 뒤 접속을 끊는다.
  - **Stateless** : 서버는 클라이언트의 상태를 저장하지 않는다.
- 위의 2가지 특성으로 인해, 사용자의 로그인 정보를 유지할 수 없다.
- 로그인한 사용자의 인증(authentication) 정보를 유지하기 위해 쿠키 혹은 세션을 사용한다.
  - cf) 인증 vs 인가
  - **인증(authentication)** : 사용자가 누구인지
    - 인증에 문제가 있는 경우 **401 Unauthorized** 에러가 발생한다.
  - **인가(authorization)** : 사용자가 어떤 권한을 가지는지
    - 인가에 문제가 있는 경우 **403 Forbidden** 에러가 발생한다.

<br>

### 쿠키 (Cookie)

- 브라우저 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일
- 사용 목적
  - 세션 관리 : 로그인, 장바구니, 게임 스코어 등의 정보 관리
  - 개인화 : 사용자 선호, 테마 등의 세팅
  - 트래킹 : 사용자 행동을 기록하고 분석
- 구성 요소
  - 필수 : 이름 / 값
  - 선택 : 만료기간 / 도메인 이름 / 요청 경로 / flags(`SameSite`, `HttpOnly`, `Secure` 등)
    - `SameSite` : 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송 (CSRF 공격 방지)
    - `HttpOnly` : 자바스크립트의 document.cookie로 쿠키 접속 금지 (XSS 공격 방지)
    - `Secure` : HTTPS 통신인 경우에만 쿠키 전송
- 쿠키의 생명 주기
  - **Session Cookie** : 만료 기간 생략 => 브라우저 종료 시까지 유지
  - **Persistent Cookie** : 만료 기간 지정 => `Expires` / `Max-age` 속성에 명시된 기간까지 유지

- 쿠키의 동작 방식
  1. 클라이언트의 요청을 받은 서버가 쿠키를 생성한다.
  2. 서버는 HTTP 헤더에 `Set-cookie` 속성으로 쿠키 정보를 담아 응답한다.
  3. 클라이언트는 쿠키를 브라우저에 저장한다.
  4. 이후 서버로 요청을 보낼 때마다 헤더에 쿠키 정보를 담아 보낸다.
  5. 서버에서 쿠키 정보를 읽고, 상태 정보를 변경해야 한다면(ex. 만료 기간 업데이트) 쿠키를 변경한 뒤 다시 HTTP 헤더에 담아 보낸다.

<br>

### 세션 (Session)

- 세션의 동작 방식
  1. 클라이언트의 요청을 받은 서버는 세션 id를 생성한다.
  2. 서버는 HTTP 헤더에 쿠키로 세션 id 정보를 담아 클라이언트에게 보낸다.
  3. 클라이언트는 브라우저에 세션 id를 저장한다.
  4. 이후 서버로 요청을 보낼 때마다 헤더에 세션 id 정보를 담아 보낸다.
  5. 서버는 요청 헤더의 세션 id를 서버에 저장된 세션 id와 비교하여 유효한지 확인한다.

<br>

### 쿠키 vs 세션

- 쿠키는 클라이언트 로컬에만 저장되며, 서버의 자원을 사용하지 않는다. 따라서 요청 속도는 더 빠르지만 보안에 취약하다.
- 세션은 클라이언트와 서버에 모두 저장된다. 따라서 요청 속도는 더 느리지만 서버에서 관리하므로 보안이 더 우수하다.
- 쿠키는 `Expires` / `Max-age` 속성을 통해 만료 기간을 지정하면, 브라우저 종료 후에도 정보가 계속 유지된다. 
- 세션은 만료 기간을 지정하더라도 브라우저 종료 시 삭제된다.

<br>

### 참고 자료

https://en.wikipedia.org/wiki/HTTP_cookie

https://interconnection.tistory.com/74

https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies