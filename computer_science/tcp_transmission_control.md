# TCP의 전송 제어 방법



### 흐름제어

> 송신측에서 전송되는 데이터의 양을 조절한다.

- 송신측이 수신측보다 데이터 처리 속도가 빠르면, 수신측의 버퍼 오버플로우가 발생할 수 있다.

- 따라서 수신측이 패킷을 너무 많이 받지 않도록 송신측에서 데이터 전송을 조절해야 한다.

- 흐름제어 방법

  1. **Stop and Wait**

     - 매번 보낸 패킷에 대한 응답을 받은 후에 다음 패킷을 전송한다.

     - TimeOut 시간 내에 응답이 없으면, 전송 실패로 간주하고 응답이 올 때까지 다시 패킷을 보낸다.

     - 비효율적이다.

       - 한 번에 하나의 패킷만을 전송할 수 있다.

       - TimeOut 시간이 너무 짧으면 전송 진행 중인 패킷을 실패로 간주할 수 있고,

         TimeOut 시간이 너무 길면 전송 실패한 패킷에 대해 너무 오래 기다리게 된다.

  2. **Sliding Window**

     ![img](./cs.assets/slidingwindow.png)

     - 비유로 이해하기
       - 좌석이 20개인 식당 앞에 사람들이 줄을 서 있다. 일단 처음에는 20명이 모두 들어가고, 이후 밥을 다 먹고 사람이 나오면, 나온 사람의 수만큼 새로운 사람이 입장한다.
     - 송신측에서 윈도우 크기를 설정한다.
       - 3 Way Handshake 과정에서 송신측과 수신측은 버퍼 크기를 공유한다.
       - **수신 윈도우 크기 (RWND)**
         - 수신측이 자신의 버퍼 크기를 바탕으로 설정한 윈도우 크기
       - **혼잡 윈도우 크기 (CWND)**
         - 송신측이 패킷의 왕복 시간(RTT) 등 네트워크 상황을 고려하여 정한 윈도우 크기
       - 송신측은 RWND와 CWND 중 더 작은 값으로 윈도우 크기를 설정한다.
       - 윈도우 크기는 이후 통신을 진행하면서 동적으로 변할 수 있다.
     - 송신 측에서는 윈도우 크기만큼 응답 없이 데이터를 전송할 수 있다.
       - **전송했지만 아직 확인(ACK)되지 않은 바이트의 수**를 제한하는 방식이다.
     - 패킷의 전달이 확인되는대로 윈도우를 옆으로 옮겨 다음 패킷들을 전송한다.
     - 오늘날의 TCP 대부분이 채택하는 흐름 제어 방식이다.

<br>

### 오류제어

> 데이터 전송에 오류가 발생한 경우 대처한다.

- TCP에서 오류를 파악하는 방법
  - a. 수신 측에서 부정응답 **NACK**을 전송
  - b. 송신 측으로 **ACK**가 오지 않거나, 중복해서 오는 경우
  - 일반적으로 2번째 방법을 사용하여 오류를 파악한다.

- TCP의 기본 오류 제어 방식 : **ARQ (Automatic Repeat Request)**

  - 통신 오류 발생시 데이터를 다시 전송하는 방식

- 오류제어 방법

  1. **Stop and Wait** (하나씩 보내줘)

     - Stop and Wait를 통해 흐름제어와 오류제어가 동시에 가능하다.

     - 하지만 앞서 살펴본 것처럼 비효율적이다.

  2. **Go Back N** (오류난 것부터 다시 보내줘)

     - 수신측에서 오류를 감지하면, 해당 데이터 이후로 받은 모든 데이터를 폐기한 뒤, 송신측에게 오류가 발생한 데이터 정보를 전달한다.

     - 오류 정보를 받은 송신측은, 오류가 발생한 데이터와 그 이후 전송한 모든 데이터를 다시 전송한다.

  3. **Selective Repeat** (오류난 것만 다시 보내줘)

     - 수신측이 오류가 발생한 데이터 정보를 송신측에 전달하면, 송신측은 그 데이터만 다시 전송한다.

     - 오류 발생 데이터만 다시 보내므로, 데이터 재정렬이 필요하다.

<br>

### 혼잡제어

> 네트워크의 혼잡에 대처한다.

- 앞서 설명한 것처럼, 송신측은 RWND와 CWND 중 작은 값으로 윈도우 크기를 설정한다.
- 송신측은 혼잡 상태를 감지한 경우, CWND를 줄임으로써 데이터 전송량을 줄이고자 한다.
- 흐름제어와의 비교
  - 흐름제어는 **송신측과 수신측**의 데이터 처리 속도 차이를 해결한다.
  - 혼잡제어는 **송신측과 네트워크**의 데이터 처리 속도 차이를 해결한다.
- 혼잡 회피 방법
  1. **AIMD** (Additive Increase / Multicative Decrease)
     - `N = N + 1` : 패킷이 잘 도착하는 경우, 윈도우 크기를 1 증가시킨다.
     - `N = N / 2` : 혼잡 상태가 감지되는 경우, 윈도우 크기를 2로 나눈다.
     - 장점 : 시간이 지나면 윈도우 크기가 평형 상태로 수렴한다.
     - 단점 : 윈도우 크기를 1씩만 증가시키다 보니, 전송 속도를 올리는데 오랜 시간이 걸린다.
  2. **Slow Start**
     - `N = N * 2` : 패킷이 잘 도착하는 경우, 각 패킷마다 윈도우 크기를 1씩 증가시킨다. 따라서 한번의 통신이 지나면 윈도우 크기가 2배가 된다.
     - `N = 1` : 혼잡 상태가 감지되면 윈도우 크기를 1로 만든다. 그리고 혼잡 현상이 발생했던 윈도우 크기의 절반을 **임계점**으로 설정한다. 이후에는 다시 윈도우 크기를 2배씩 증가시키다가, 임계점을 넘어가면 1씩 증가시킨다.
     - 높은 대역폭을 사용하는데 오랜 시간이 걸리는 AIMD의 단점을 극복한다.
- 혼잡 제어 정책
  - Tahoe, Reno, New Reno, Cubic, Elastic-TCP 등
  - 혼잡 제어 정책에서는 일반적으로 AIMD와 Slow Start 방법을 함께 사용한다.
  - Tahoe와 Reno의 경우, 처음에는 Slow Start 방식을 사용했다가, 윈도우 크기가 임계점을 넘어가면 AIMD 방식을 사용한다.

<br>

### 참고 출처

https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/

https://evan-moon.github.io/2019/11/26/tcp-congestion-control/

https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html

https://www.brianstorti.com/tcp-flow-control/